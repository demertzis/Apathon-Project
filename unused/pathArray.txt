
  function findPath(path = null, pathsAccessed = null, startPos = null, offset = 0.05) {

    if (!path)
      return null;
    
    if (path.length > 4)
      return null;

    // pathsAccessed[path[path.length - 1]] = true;

    let i = 0;
    l = workingArray.length;
    // for (; i < l; i++)
    // if (pathsAccessed[i] == true && workingArray[i].hasOpposite !== false)
    // pathsAccessed[workingArray[workingArray[i].hasOpposite]] = true;
    function getNewPathsAccessed(pathToAdd = null) {
      let newPathsAccessed = pathsAccessed;
      if (!newPathsAccessed.includes(pathToAdd))
        newPathsAccessed.push(pathToAdd);
      let possibleOpposite = workingArray[pathToAdd].hasOpposite;
      if (possibleOpposite !== false) {
        if (!newPathsAccessed.includes(possibleOpposite))
          newPathsAccessed.push(possibleOpposite);
        if (!newPathsAccessed.includes(workingArray[possibleOpposite].hasOpposite))
          newPathsAccessed.push(workingArray[possibleOpposite].hasOpposite);
      }
      return newPathsAccessed;
    }

    pathsAccessed = getNewPathsAccessed(path[path.length - 1]);

    let destDevice = {
      lat: Number(devicesArray[workingArray[path[path.length - 1]].Path_destination_device_id].lat),
      lng: Number(devicesArray[workingArray[path[path.length - 1]].Path_destination_device_id].lng)
    }

    let dist1 = distance(startPos, destination);
    let dist2 = distance(destDevice, destination);
    let dist3 = distance(destDevice, startPos);

    if (dist1 < 0.2 ||
      dist2 < 0.2 ||
      (workingArray[path[path.length - 1]].close_to_finish &&
        (dist2 <=
          dist3)))
      return path;
    if (workingArray[path[path.length - 1]].close_to_finish &&
      dist2 >
      dist3)
      return null;


    i = 0;
    l = workingArray.length;
    let crossArray = [];

    for (; i < l; i++)
      if (i != path[path.length - 1] &&
        !pathsAccessed.includes(i) &&
        concaveCross(workingArray[i].polyline,
          workingArray[path[path.length - 1]].polyline,
          offset)
      )
        crossArray.push(i);

    i = 0;
    l = crossArray.length;

    for (; i < l; i++) {

      let pathPoints = workingArray[path[path.length - 1]].polyline.split(' ');
      let newStartPos = polylineDistance(startPos, workingArray[crossArray[i]].polyline);

      let j = newStartPos.pointId;
      let l2 = pathPoints.length;

      for (; j < l2; j++) {
        let point = {
          lat: Number(pathPoints[j].split(',')[1]),
          lng: Number(pathPoints[j].split(',')[0])
        }

        let candidateStartPos = polylineDistance(point, workingArray[crossArray[i]].polyline);
        newStartPos = newStartPos.dist > candidateStartPos.dist ?
          candidateStartPos :
          newStartPos;
        if (newStartPos.dist < 0.01)
          break;
      }

      if (newStartPos.dist > 0.1) {
        crossArray.splice(i, 1);
        l--;
        i--;
        continue;
      }

      let newPath = path.concat([crossArray[i]]);
      let newPathsAccessed = pathsAccessed;


      j = 0;
      l = crossArray.length - 1;
      for (; j < l; j++)
        newPathsAccessed = j != i ? getNewPathsAccessed(crossArray[j]) : newPathsAccessed


      let pathContinuation = findPath(newPath, newPathsAccessed, {
        lat: newStartPos.lat,
        lng: newStartPos.lng
      }, offset);

      if (Array.isArray(pathContinuation))
        return pathContinuation;
      else
        continue;
    }

    return null;
  }
